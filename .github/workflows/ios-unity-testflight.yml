name: Unity iOS (manual) → TestFlight

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  BUNDLE_ID: ${{ secrets.BUNDLE_ID }}
  # Опционально: зафиксируй схему приложения вручную (например, Unity-iPhone)
  XCODE_SCHEME: Unity-iPhone

jobs:
  unity-export-ios:
    name: Export Xcode project (Unity)
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4

      - uses: actions/cache@v4
        with:
          path: Library
          key: Library-${{ runner.os }}-iOS

      - name: Xcode version
        run: xcodebuild -version

      - name: Assert UNITY_LICENSE is present
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
        run: |
          if [ -z "${UNITY_LICENSE}" ]; then
            echo "UNITY_LICENSE is EMPTY (secret не проброшен в джоб)"; exit 1
          fi
          echo "UNITY_LICENSE length: $(printf %s "$UNITY_LICENSE" | wc -c)"

      - name: Normalize UNITY_LICENSE newlines
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
        run: |
          clean=$(printf "%s" "$UNITY_LICENSE" | tr -d '\r')
          {
            echo "UNITY_LICENSE<<EOF"
            echo "$clean"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Build (Unity → iOS)
        uses: game-ci/unity-builder@v4
        with:
          targetPlatform: iOS
        env:
          UNITY_LICENSE: ${{ secrets.UNITY_LICENSE }}
          UNITY_EMAIL: ${{ secrets.UNITY_EMAIL }}
          UNITY_PASSWORD: ${{ secrets.UNITY_PASSWORD }}

      - uses: actions/upload-artifact@v4
        with:
          name: xcode-ios
          path: build/iOS

  xcode-archive-upload:
    name: Sign, archive & upload to TestFlight
    needs: [unity-export-ios]
    runs-on: macos-14
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: xcode-ios
          path: build/iOS

      - name: Xcode version
        run: xcodebuild -version

      - name: Install xcpretty
        run: sudo gem install xcpretty -N

      - name: Import signing certificate (.p12)
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.IOS_P12_BASE64 }}
          p12-password: ${{ secrets.IOS_P12_PASSWORD }}

      - name: Install provisioning profile
        run: |
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          PROFILE_PATH="$HOME/Library/MobileDevice/Provisioning Profiles/appstore.mobileprovision"
          echo "${{ secrets.IOS_MOBILEPROVISION_BASE64 }}" | base64 --decode > "$PROFILE_PATH"

      - name: Bump build number (CFBundleVersion)
        run: |
          set -euo pipefail
          cd build/iOS
          agvtool new-version -all $GITHUB_RUN_NUMBER || true

      - name: Archive (manual signing, smart scheme detection)
        env:
          TEAM_ID: ${{ secrets.TEAM_ID }}
          XCODE_SCHEME: ${{ env.XCODE_SCHEME }}
        run: |
          set -euo pipefail
          cd build/iOS

          # --- workspace/project detection (предпочитаем Unity-iPhone.xcworkspace) ---
          if [ -f "Unity-iPhone.xcworkspace" ]; then
            PROJ_PATH="Unity-iPhone.xcworkspace"
            PROJ=(-workspace "$PROJ_PATH")
          else
            if compgen -G "*.xcworkspace" >/dev/null; then
              PROJ_PATH="$(ls -1 *.xcworkspace | head -n1)"
              PROJ=(-workspace "$PROJ_PATH")
            elif compgen -G "*.xcodeproj" >/dev/null; then
              PROJ_PATH="$(ls -1 *.xcodeproj | head -n1)"
              PROJ=(-project "$PROJ_PATH")
            else
              echo "❌ Ни .xcworkspace, ни .xcodeproj не найдено в $(pwd)."; ls -la; exit 66
            fi
          fi

          # --- scheme detection: берём из env, иначе ищем схему с продуктом .app ---
          if [ -n "${XCODE_SCHEME:-}" ]; then
            SCHEME="$XCODE_SCHEME"
          else
            mapfile -t ALL_SCHEMES < <(xcodebuild -list -json "${PROJ[@]}" | /usr/bin/python3 -c 'import sys,json; j=json.load(sys.stdin); p=j.get("workspace") or j.get("project") or {}; print("\n".join(p.get("schemes") or []))')
            SCHEME=""
            for s in "${ALL_SCHEMES[@]}"; do
              if xcodebuild "${PROJ[@]}" -scheme "$s" -showBuildSettings 2>/dev/null \
                 | grep -qE 'WRAPPER_EXTENSION[[:space:]]*=[[:space:]]*app|PRODUCT_BUNDLE_PACKAGE_TYPE[[:space:]]*=[[:space:]]*APPL'; then
                SCHEME="$s"; break
              fi
            done
            if [ -z "$SCHEME" ]; then
              echo "❌ Не нашли app-scheme среди: ${ALL_SCHEMES[*]}"; exit 66
            fi
          fi

          echo "✅ Using project: $PROJ_PATH"
          echo "✅ Using scheme : $SCHEME"

          set -o pipefail
          xcodebuild "${PROJ[@]}" \
            -scheme "$SCHEME" \
            -configuration Release \
            -archivePath out.xcarchive \
            -destination 'generic/platform=iOS' \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="${TEAM_ID}" \
            PRODUCT_BUNDLE_IDENTIFIER="${BUNDLE_ID}" \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            clean archive | xcpretty

      - name: Sanity check archive (detect Generic Archive)
        run: |
          set -euo pipefail
          cd build/iOS

          /usr/bin/plutil -p out.xcarchive/Info.plist || true

          # быстрый детектор App Archive
          if ! /usr/bin/plutil -extract ApplicationProperties xml1 -o - out.xcarchive/Info.plist >/dev/null 2>&1; then
            echo "⚠️ Похоже, это Generic Archive (нет ApplicationProperties)."
            # Чистку DocC делаем только если есть каталог Applications
            if [ -d out.xcarchive/Products/Applications ]; then
              echo "Попробуем убрать DocC-пакеты рядом с .app…"
              find out.xcarchive/Products/Applications -maxdepth 1 -type d -name "*.docarchive" -print -exec rm -rf {} \; || true
            else
              echo "Нет out.xcarchive/Products/Applications — пропускаю DocC-чистку."
            fi
          fi

          # повторная проверка
          if ! /usr/bin/plutil -extract ApplicationProperties xml1 -o - out.xcarchive/Info.plist >/dev/null 2>&1; then
            echo "❌ Архив по-прежнему Generic. Частая причина — выбран не app-scheme или Skip Install неверно настроен."
            exit 70
          fi

      - name: Create ExportOptions.plist (App Store)
        env:
          PROFILE_NAME: ${{ secrets.IOS_PROFILE_NAME }}
        run: |
          set -euo pipefail
          cd build/iOS
          /usr/bin/python3 -c 'import os,plistlib; plist={"method":"app-store","destination":"export","signingStyle":"manual","provisioningProfiles":{os.environ["BUNDLE_ID"]:os.environ["PROFILE_NAME"]},"signingCertificate":"Apple Distribution","stripSwiftSymbols":True,"uploadSymbols":True}; plistlib.dump(plist,open("ExportOptions.plist","wb"))'
          /usr/bin/plutil -lint ExportOptions.plist
          /usr/bin/plutil -p ExportOptions.plist

      - name: Export IPA
        run: |
          set -euo pipefail
          cd build/iOS
          xcodebuild -exportArchive \
            -archivePath out.xcarchive \
            -exportPath out \
            -exportOptionsPlist ExportOptions.plist | xcpretty
          ls -lah out

      - name: Setup Ruby & fastlane
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Install fastlane
        run: gem install fastlane -N

      - name: Write asc_api_key.json
        run: |
          cat > asc_api_key.json <<JSON
          { "key_id":"${{ secrets.ASC_KEY_ID }}",
            "issuer_id":"${{ secrets.ASC_ISSUER_ID }}",
            "key":"${{ secrets.ASC_API_KEY_P8 }}" }
          JSON

      - name: Upload IPA to TestFlight
        env:
          APPLE_APP_ID: ${{ secrets.APPLE_APP_ID }}
          TESTFLIGHT_GROUPS: ${{ secrets.TESTFLIGHT_GROUPS }}
        run: |
          set -euo pipefail
          IPA=$(ls build/iOS/out/*.ipa | head -n1)
          if [ -z "${TESTFLIGHT_GROUPS}" ]; then
            fastlane pilot upload --api_key_path asc_api_key.json --apple_id "${APPLE_APP_ID}" --ipa "$IPA"
          else
            fastlane pilot upload --api_key_path asc_api_key.json --apple_id "${APPLE_APP_ID}" --ipa "$IPA" \
              --distribute_external true --groups "$TESTFLIGHT_GROUPS"
          fi

      - uses: actions/upload-artifact@v4
        with:
          name: ipa
          path: build/iOS/out/*.ipa
